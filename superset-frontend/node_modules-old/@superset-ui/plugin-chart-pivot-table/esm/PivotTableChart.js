/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import React from 'react';
import { styled, getNumberFormatter } from '@superset-ui/core'; // @ts-ignore

import PivotTable from '@superset-ui/react-pivottable/PivotTable'; // @ts-ignore

import { sortAs, aggregatorTemplates } from '@superset-ui/react-pivottable/Utilities';
import '@superset-ui/react-pivottable/pivottable.css';
import { jsx as ___EmotionJSX } from "@emotion/react";
const Styles = styled.div`
  padding: ${({
  theme
}) => theme.gridUnit * 4}px;
  height: ${({
  height
}) => height}px;
  width: ${({
  width
}) => width}px;
  overflow-y: scroll;
  }
`; // TODO: remove eslint-disable when click callbacks are implemented

/* eslint-disable @typescript-eslint/no-unused-vars */

const clickCellCallback = (e, value, filters, pivotData) => {// TODO: Implement a callback
};

const clickColumnHeaderCallback = (e, value, filters, pivotData, isSubtotal, isGrandTotal) => {// TODO: Implement a callback
};

const clickRowHeaderCallback = (e, value, filters, pivotData, isSubtotal, isGrandTotal) => {// TODO: Implement a callback
};

export default function PivotTableChart(props) {
  const {
    data,
    height,
    width,
    groupbyRows,
    groupbyColumns,
    metrics,
    tableRenderer,
    colOrder,
    rowOrder,
    aggregateFunction,
    transposePivot,
    rowSubtotalPosition,
    colSubtotalPosition,
    colTotals,
    rowTotals,
    valueFormat
  } = props;
  const adaptiveFormatter = getNumberFormatter(valueFormat);

  const aggregators = (tpl => ({
    Count: tpl.count(adaptiveFormatter),
    'Count Unique Values': tpl.countUnique(adaptiveFormatter),
    'List Unique Values': tpl.listUnique(', '),
    Sum: tpl.sum(adaptiveFormatter),
    Average: tpl.average(adaptiveFormatter),
    Median: tpl.median(adaptiveFormatter),
    'Sample Variance': tpl.var(1, adaptiveFormatter),
    'Sample Standard Deviation': tpl.stdev(1, adaptiveFormatter),
    Minimum: tpl.min(adaptiveFormatter),
    Maximum: tpl.max(adaptiveFormatter),
    First: tpl.first(adaptiveFormatter),
    Last: tpl.last(adaptiveFormatter),
    'Sum as Fraction of Total': tpl.fractionOf(tpl.sum(), 'total', adaptiveFormatter),
    'Sum as Fraction of Rows': tpl.fractionOf(tpl.sum(), 'row', adaptiveFormatter),
    'Sum as Fraction of Columns': tpl.fractionOf(tpl.sum(), 'col', adaptiveFormatter),
    'Count as Fraction of Total': tpl.fractionOf(tpl.count(), 'total', adaptiveFormatter),
    'Count as Fraction of Rows': tpl.fractionOf(tpl.count(), 'row', adaptiveFormatter),
    'Count as Fraction of Columns': tpl.fractionOf(tpl.count(), 'col', adaptiveFormatter)
  }))(aggregatorTemplates);

  const metricNames = metrics.map(metric => typeof metric === 'string' ? metric : metric.label);
  const unpivotedData = data.reduce((acc, record) => [...acc, ...metricNames.map(name => ({ ...record,
    metric: name,
    value: record[name]
  }))], []);
  const [rows, cols] = transposePivot ? [groupbyColumns, ['metric', ...groupbyRows]] : [groupbyRows, ['metric', ...groupbyColumns]];
  return ___EmotionJSX(Styles, {
    height: height,
    width: width
  }, ___EmotionJSX(PivotTable, {
    data: unpivotedData,
    rows: rows,
    cols: cols,
    aggregators: aggregators,
    aggregatorName: aggregateFunction,
    vals: ['value'],
    rendererName: tableRenderer,
    colOrder: colOrder,
    rowOrder: rowOrder,
    sorters: {
      metric: sortAs(metricNames)
    },
    tableOptions: {
      clickCallback: clickCellCallback,
      clickRowHeaderCallback,
      clickColumnHeaderCallback,
      colTotals,
      rowTotals
    },
    subtotalOptions: {
      colSubtotalDisplay: {
        displayOnTop: colSubtotalPosition
      },
      rowSubtotalDisplay: {
        displayOnTop: rowSubtotalPosition
      }
    }
  }));
}